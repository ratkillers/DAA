<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knapsack DP</title>
</head>
<body>
 <h1>Knapsack DP</h1>
 <pre>
    #include <bits/stdc++.h> 

    using namespace std; 
    
      
    
    
    int max(int a, int b) { return (a > b) ? a : b; } 
   
    
    int knapSack(int W, int wt[], int val[], int n) 
    { 
    
      
    
        // Base Case 
    
        if (n == 0 || W == 0) 
    
            return 0; 
    
      
    
    
        if (wt[n - 1] > W) 
    
            return knapSack(W, wt, val, n - 1); 
    
      
    
    
        else
    
            return max( 
    
                val[n - 1] 
    
                    + knapSack(W - wt[n - 1],  
    
                               wt, val, n - 1), 
    
                knapSack(W, wt, val, n - 1)); 
    } 
    
      
  
    
    int main() 
    { 
    
        int val[] = { 60, 100, 120 }; 
    
        int wt[] = { 10, 20, 30 }; 
    
        int W = 50; 
    
        int n = sizeof(val) / sizeof(val[0]); 
    
        cout << knapSack(W, wt, val, n); 
    
        return 0; 
    }
</pre>
<h2>time</h2>
<pre>Complexity Analysis: 

    Time Complexity: O(N*W). 
    where ‘N’ is the number of weight element and ‘W’ is capacity. As for every weight element we traverse through all weight capacities 1<=w<=W.
    Auxiliary Space: O(N*W). 
    The use of 2-D array of size ‘N*W’.</pre>
<h2>algo</h2>
<pre>Dynamic-0-1-knapsack (v, w, n, W) 
    for w = 0 to W do 
       c[0, w] = 0 
    for i = 1 to n do 
       c[i, 0] = 0 
       for w = 1 to W do 
          if wi ≤ w then 
             if vi + c[i-1, w-wi] then 
                c[i, w] = vi + c[i-1, w-wi] 
             else c[i, w] = c[i-1, w] 
          else 
             c[i, w] = c[i-1, w]</pre>
</body>
</html>
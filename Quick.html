<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Sort</title>
</head>
<body>
   <h1>QUICK SORT</h1> 
   <pre>#include <bits/stdc++.h>
   void swap(int* a, int* b)
   {
       int t = *a;
       *a = *b;
       *b = t;
   }
   
   int partition (int arr[], int low, int high)
   {
       int pivot = arr[high]; 
       int i = (low - 1);
   
       for (int j = low; j <= high - 1; j++)
       {
           
           if (arr[j] < pivot)
           {
               i++; 	
               swap(&arr[i], &arr[j]);
           }
       }
       swap(&arr[i + 1], &arr[high]);
       return (i + 1);
   }
   void quickSort(int arr[], int low, int high)
   {
       if (low < high)
       {
           
       
           int pi = partition(arr, low, high);
           quickSort(arr, low, pi - 1);
           quickSort(arr, pi + 1, high);
       }
   }
   
   void printArray(int arr[], int size)
   {
       int i;
       for (i = 0; i < size; i++)
           cout << arr[i] << " ";
       cout << endl;
   }
   
   int main()
   {
       int arr[] = {10, 7, 8, 9, 1, 5};
       int n = sizeof(arr) / sizeof(arr[0]);
       quickSort(arr, 0, n - 1);
       cout << "Sorted array: \n";
       printArray(arr, n);
       return 0;
   }</pre>
   <h2>Algo</h2>
   <pre>
    QUICK SORTING
    Step 1 − Make the right-most index value pivot
    Step 2 − partition the array using pivot value
    Step 3 − quicksort left partition recursively
    Step 4 − quicksort right partition recursively
    PARTITIONING
    Step 1 − Choose the highest index value has pivot
    Step 2 − Take two variables to point left and right of the list excluding pivot
    Step 3 − left points to the low index
    Step 4 − right points to the high
    Step 5 − while value at left is less than pivot move right
    Step 6 − while value at right is greater than pivot move left
    Step 7 − if both step 5 and step 6 does not match swap left and right
    Step 8 − if left ≥ right, the point where they met is new pivot
    
   </pre>
   <h2>Time</h2>
   <pre>
    Time taken by QuickSort, in general, can be written as following. 

    T(n) = T(k) + T(n-k-1) + \theta(n)
   The first two terms are for two recursive calls, the last term is for the partition process. k is the number of elements which are smaller than pivot. 
   The time taken by QuickSort depends upon the input array and partition strategy. Following are three cases.
   
   Worst Case: 
   The worst case occurs when the partition process always picks greatest or smallest element as pivot. If we consider above partition strategy where last element is always picked as pivot, the worst case would occur when the array is already sorted in increasing or decreasing order. Following is recurrence for worst case.  
   
    T(n) = T(0) + T(n-1) + \theta(n)which is equivalent to  T(n) = T(n-1) + \theta(n)
   The solution of above recurrence is  <strong>\theta          </strong>(n2). 
   
   Best Case:
    The best case occurs when the partition process always picks the middle element as pivot. Following is recurrence for best case. 
   
    T(n) = 2T(n/2) + \theta(n)
   The solution of above recurrence is <strong>\theta          </strong>(nLogn). It can be solved using
   </pre>
</body>
</html>